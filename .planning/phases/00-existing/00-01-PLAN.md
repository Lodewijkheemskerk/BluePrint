# Fix Plan: UAT Issues from Phase 00-existing

**Phase:** 00-existing  
**Mode:** gap_closure  
**Created:** 2026-02-17  
**Status:** ✅ Complete (all fixes implemented)

## Objective

Fix 4 issues identified during UAT testing:
1. Setup detail modal doesn't open (major)
2. Inactive strategies still show in list (major)
3. Scan running status not visible (minor)
4. Backtester input white background (cosmetic)

## Gaps to Close

See `.planning/phases/00-existing/00-UAT.md` for full gap details with root causes.

## Fix Plan

### Fix 1: Setup Detail Modal Not Opening

**Root Cause:** onclick handler may not be accessible when table renders, or JavaScript error preventing execution.

**Files to Modify:**
- `frontend/js/app.js`

**Changes:**
1. Replace inline onclick handlers with event delegation
2. Add error handling in `showSetupDetail()` function
3. Ensure `window.app` is available before table rendering

**Implementation:**
```javascript
// In renderSetupsTable(), remove onclick from template
// Add event listener using event delegation on tbody
document.getElementById('setups-tbody').addEventListener('click', (e) => {
    const row = e.target.closest('tr');
    if (row && row.dataset.setupId) {
        window.app.showSetupDetail(parseInt(row.dataset.setupId));
    }
});

// Add data-setup-id attribute to rows
tbody.innerHTML = setups.map(s => `
    <tr data-setup-id="${s.id}" style="cursor:pointer">
        ...
    </tr>
`).join('');

// Add try-catch in showSetupDetail()
async function showSetupDetail(setupId) {
    try {
        // existing code
    } catch (e) {
        console.error('Failed to show setup detail:', e);
        showToast('Failed to load setup: ' + e.message, 'error');
    }
}
```

**Verification:**
- Click on setup row → modal opens
- Check browser console for errors
- Test with multiple setups

---

### Fix 2: Inactive Strategies Still Show in List

**Root Cause:** API endpoint returns all strategies without filtering by is_active. Frontend also doesn't filter.

**Files to Modify:**
- `backend/routers/strategies.py`
- `frontend/js/app.js` (optional - can filter on frontend instead)

**Option A: Backend Filter (Recommended)**
```python
@router.get("/", response_model=List[StrategyResponse])
def list_strategies(active_only: bool = False, db: Session = Depends(get_db)):
    query = db.query(Strategy)
    if active_only:
        query = query.filter(Strategy.is_active == True)
    strategies = query.order_by(Strategy.created_at.desc()).all()
    # ... rest of function
```

**Option B: Frontend Filter**
```javascript
async function loadStrategies() {
    const strategies = await api.getStrategies();
    // Filter to show only active strategies
    const activeStrategies = strategies.filter(s => s.is_active);
    // ... render activeStrategies
}
```

**Recommended:** Option A (backend filter) - more efficient and allows frontend to optionally show inactive strategies.

**Verification:**
- Toggle strategy to inactive → disappears from list
- Toggle back to active → reappears in list
- API returns only active strategies when filtered

---

### Fix 3: Scan Running Status Not Visible

**Root Cause:** Scan log created in background thread, doesn't exist when table loads immediately after trigger.

**Files to Modify:**
- `backend/routers/scans.py`
- `frontend/js/app.js`

**Changes:**
1. Create scan log BEFORE starting background thread
2. Return scan_id immediately from trigger_scan()
3. Frontend can show placeholder or poll for scan

**Implementation:**
```python
@router.post("/trigger", response_model=ScanTriggerResponse)
def trigger_scan(db: Session = Depends(get_db)):
    """Trigger a manual scan cycle in a background thread."""
    # Create scan log FIRST
    scan_log = ScanLog(started_at=datetime.now(timezone.utc), status="running")
    db.add(scan_log)
    db.commit()
    db.refresh(scan_log)
    scan_id = scan_log.id
    
    def _run():
        from backend.scanner.engine import run_scan
        session = SessionLocal()
        try:
            # Update existing log instead of creating new one
            run_scan(session, scan_id=scan_id)
        finally:
            session.close()
    
    thread = threading.Thread(target=_run, daemon=True)
    thread.start()
    
    return ScanTriggerResponse(
        message="Scan triggered — running in background",
        scan_id=scan_id,  # Return the scan_id
    )
```

**Update engine.py to accept scan_id:**
```python
def run_scan(db: Session, scan_id: Optional[int] = None) -> ScanLog:
    if scan_id:
        scan_log = db.query(ScanLog).filter(ScanLog.id == scan_id).first()
    else:
        scan_log = ScanLog(started_at=datetime.now(timezone.utc))
        db.add(scan_log)
        db.commit()
        _current_scan_log_id = scan_log.id
    # ... rest of function
```

**Verification:**
- Trigger scan → appears in table immediately with "running" status
- Spinner shows while scan is running
- Status updates when scan completes

---

### Fix 4: Backtester Input White Background

**Root Cause:** Browser autofill styling overrides dark background.

**Files to Modify:**
- `frontend/css/styles.css`

**Changes:**
Add explicit background-color to focus and autofill states.

**Implementation:**
```css
.form-input:focus,
.form-select:focus,
.form-textarea:focus {
    outline: none;
    border-color: var(--accent);
    background-color: var(--bg-primary) !important; /* Add this */
}

/* Add autofill styling */
.form-input:-webkit-autofill,
.form-input:-webkit-autofill:hover,
.form-input:-webkit-autofill:focus {
    -webkit-box-shadow: 0 0 0px 1000px var(--bg-primary) inset !important;
    -webkit-text-fill-color: var(--text-primary) !important;
    background-color: var(--bg-primary) !important;
}
```

**Verification:**
- Enter text in backtester symbols field → background stays dark
- Test in Chrome, Firefox, Edge
- Verify all form inputs maintain dark theme

---

## Execution Order

1. Fix 4 (cosmetic) - Quickest, low risk
2. Fix 2 (major) - Backend change, straightforward
3. Fix 3 (minor) - Requires coordination between backend files
4. Fix 1 (major) - Requires careful testing of event handling

## Testing

After each fix:
- Test the specific functionality
- Verify no regressions in related features
- Check browser console for errors

## Estimated Scope

- **Small:** Fix 4 (CSS only)
- **Small:** Fix 2 (API filter)
- **Medium:** Fix 3 (backend coordination)
- **Medium:** Fix 1 (event handling refactor)

**Total:** Medium scope (4 fixes, 2-3 hours)
